     1                                  bits 64
     2                                  default rel
     3                                  global _start
     4                                  
     5                                  section .data
     6 00000000 577269746520736F6D-         write_msg db "Write some string: ", 0
     6 00000009 6520737472696E673A-
     6 00000012 2000               
     7                                      write_msg_len  equ $ - write_msg
     8 00000014 537472696E67207368-         err_empty_str db "String should contain at least one character, try again", 10
     8 0000001D 6F756C6420636F6E74-
     8 00000026 61696E206174206C65-
     8 0000002F 617374206F6E652063-
     8 00000038 68617261637465722C-
     8 00000041 207472792061676169-
     8 0000004A 6E0A               
     9                                      err_empty_str_len equ $ - err_empty_str
    10 0000004C 50726F6772616D2065-         err_critical_problem db "Program encountered critical error during read_stdin, flip_string or write_stdout", 10
    10 00000055 6E636F756E74657265-
    10 0000005E 642063726974696361-
    10 00000067 6C206572726F722064-
    10 00000070 7572696E6720726561-
    10 00000079 645F737464696E2C20-
    10 00000082 666C69705F73747269-
    10 0000008B 6E67206F7220777269-
    10 00000094 74655F7374646F7574-
    10 0000009D 0A                 
    11                                      err_critical_problem_len equ $ - err_critical_problem
    12                                  
    13                                  section .bss
    14 00000000 <res 400h>                  input resb 1024             ; 1KB массив для входных данных
    15 00000400 <res 400h>                  reversed_str resb 1024      ; 1KB массив для "перевернутой" строки
    16                                  
    17                                  section .text
    18                                  _start:
    19 00000000 48BB-                       mov rbx, input                  ; Передаем указатель на массив, куда попадет исходная строка
    19 00000002 [0000000000000000] 
    20 0000000A B900040000                  mov rcx, 1024                   ; Передаем размер этого массива
    21 0000000F E845000000                  call read_stdin                 ; Вызываем функцию чтения из stdin
    22                                  
    23 00000014 48BF-                       mov rdi, input                  ; Передаем указатель на массив, содержащий исходную строку
    23 00000016 [0000000000000000] 
    24 0000001E 48BE-                       mov rsi, reversed_str           ; Передаем указатель на массив, куда попадет перевернутая строка
    24 00000020 [0004000000000000] 
    25 00000028 4889C2                      mov rdx, rax                    ; Передаем размер исходной строки
    26 0000002B 41B900040000                mov r9, 1024                    ; Передаем размер reversed_std
    27 00000031 4989C2                      mov r10, rax                    ; Сохраняем размер исходной строки
    28                                  
    29 00000034 E85B000000                  call flip_string                ; Вызываем функцию "переворота" строки
    30                                      
    31 00000039 4939C2                      cmp r10, rax                    ; Проверяем, что "переворот" строки прошел успешно
    32 0000003C 0F85B5000000                jnz exit_with_error
    33                                  
    34 00000042 48BE-                       mov rsi, reversed_str           ; Выводим полученную строку 
    34 00000044 [0004000000000000] 
    35 0000004C 4889C2                      mov rdx, rax
    36                                  
    37 0000004F E885000000                  call write_stdout
    38                                  
    39 00000054 E992000000                  jmp exit
    40                                  
    41                                  ; --- read_stdin ---
    42                                  ; @brief    Фукнция для чтения из stdin
    43                                  ; @param    rbx - указатель на массив, в который будут записаны данные
    44                                  ; @param    rcx - размер переданного массива
    45                                  ; @return   rax - размер записанных в массив данных
    46                                  ; @note     Аналог на Си: int read_stdin(char* input, size_t input_size)
    47                                  ; @note     Проверяет rax на содержание кода ошибки (отрицательное число) после
    48                                  ; @note     чтения из stdin
    49                                  read_stdin:
    50 00000059 B800000000                  mov rax, 0                      ; 0 - sys_read
    51 0000005E BF00000000                  mov rdi, 0                      ; 0 - stdin
    52 00000063 4889DE                      mov rsi, rbx                    ; передаем указатель на массив, в который попадут введенные данные
    53 00000066 4889CA                      mov rdx, rcx 
    54 00000069 0F05                        syscall
    55                                  
    56 0000006B 4885C0                      test rax, rax                   ; Проверка на корректное вовзращенное значение (>=0)
    57 0000006E 0F8883000000                js exit_with_error
    58                                  
    59 00000074 803D(00000000)0A            cmp byte [input], 0x0A          ; Проверка на строку, стостоящую только из перевода каретки 
    60 0000007B 7401                        je empty_string_warning         ; Переход, если первый знак в input == 0x0A
    61                                  
    62 0000007D C3                          ret
    63                                  
    64                                  ; Сообщение о пустой строке
    65                                  empty_string_warning:
    66 0000007E 48BE-                       mov rsi, err_empty_str          ; Передаем указатель на строку с информацей об ошибке 
    66 00000080 [1400000000000000] 
    67 00000088 BA38000000                  mov rdx, err_empty_str_len      ; Передаем ее длину
    68                                      
    69 0000008D E847000000                  call write_stdout               ; Вызываем функцию записи в stdout
    70                                  
    71 00000092 EBC5                        jmp read_stdin                  ; Повторяем попытку получить корректную строку от пользователя
    72                                  ; --- read_stdin ---
    73                                  
    74                                  ; По-хорошему добавить еще один аргумент - размер массива, куда попадут данные,
    75                                  ; чтобы проверять на возможность переполнения. (Если этот комметарий остался,
    76                                  ; значит я не успел это сделать)
    77                                  ; --- flip_string ---
    78                                  ; @brief    Фукнция для "переворота" строки
    79                                  ; @param    rdi - указатель на массив исходных данных
    80                                  ; @param    rsi - указатель на массив, куда будет записана "перевенутая" строка
    81                                  ; @param    rdx - размер исходных данных
    82                                  ; @param    r9  - размер массива для записи данных (rsi)
    83                                  ; @return   rax - размер записанных в массив, переданный в rsi, данных
    84                                  ; @note     Аналог на Си: int flip_string(char* input, char* output, size_t input_size)
    85                                  ; @note     Если rdx < 1 возвращает код ошибки -1
    86                                  ; @note     Если размер исходных занных больше размера массива для записи
    87                                  ; @note     данных, возвращаемт код ошибки -2 
    88                                  
    89                                  ; Инициализация необходимых значений
    90                                  flip_string:
    91 00000094 4883FA01                    cmp rdx, 1                      ; Если размер исходных данных меньше 1
    92 00000098 7C2F                        jl exit_flip_string_with_error  ; выходим с ошибкой
    93                                  
    94 0000009A 4C39CA                      cmp rdx, r9                     ; Если размер исходных данных больше размера
    95 0000009D 7F32                        jg exit_flip_string_overflow    ; массива, куда будут попадать "перевернутые" данные, выходим с ошибкой
    96                                  
    97 0000009F 4889D1                      mov rcx, rdx                    ; Инициализируем счетчик, который будет указывать на текущий последний знак в строке
    98 000000A2 48FFC9                      dec rcx                         ; Пропускаем перевод каретки
    99 000000A5 4D31C9                      xor r9, r9                      ; обнуляем r9, так как будем исользовать
   100                                                                      ; его в качестве счетчика обработанный байт
   101                                  
   102                                  ; "Переворот" данных
   103                                  flip_string_loop:
   104 000000A8 48FFC9                      dec rcx                         ; уменьшаем счетчик, который указывает на конец input
   105 000000AB 780C                        js end_flip_string              ; если он стал отрицательным, значит инвесия закончена - выходим
   106                                  
   107 000000AD 8A040F                      mov al, [rdi + rcx]             ; Получаем последний знак на данный момент 
   108                                                                      ; al - младший байт регистра RAX, в данном случае необходим, так как данные длиной 1 байт 
   109 000000B0 4288040E                    mov [rsi + r9], al              ; помещаем последний знак в начало reversed_str
   110 000000B4 49FFC1                      inc r9
   111                                  
   112 000000B7 EBEF                        jmp flip_string_loop            ; Повторяем, пока не обработаем все знаки
   113                                  
   114                                  ; Вставка перевода каретки в конец перевернутой строки
   115                                  end_flip_string: 
   116 000000B9 B00A                        mov al, 10
   117 000000BB 418881[00040000]            mov [reversed_str + r9], al     ; Перевод каретки
   118 000000C2 49FFC1                      inc r9
   119                                  
   120 000000C5 4C89C8                      mov rax, r9
   121                                  
   122 000000C8 C3                          ret
   123                                  
   124                                  exit_flip_string_with_error:
   125 000000C9 48C7C0FFFFFFFF              mov rax, -1
   126 000000D0 C3                          ret
   127                                  
   128                                  exit_flip_string_overflow:
   129 000000D1 48C7C0FEFFFFFF              mov rax, -2
   130 000000D8 C3                          ret
   131                                  ; --- flip_string ---
   132                                  
   133                                  ; --- write_stdout ---
   134                                  ; @brief    Фукнция для записи в stdout
   135                                  ; @param    r9 - указатель на буфер, из которого будут извлечены данные
   136                                  ; @param    r10 - количество байт, которые необходимо записать в stdout
   137                                  ; @return   rax - размер записанных в stdout данных
   138                                  ; @note     Аналог на Си: int write_stdout(char* data, size_t input_size)
   139                                  ; @note     Проверяет rax на соответствие r9 после записи в stdout
   140                                  write_stdout:
   141 000000D9 B801000000                  mov rax, 1                      ; 1 - sys_write
   142 000000DE BF01000000                  mov rdi, 1                      ; 1 - stdout
   143 000000E3 0F05                        syscall
   144                                  
   145 000000E5 4839C2                      cmp rdx, rax                    ; Проверить, что все данные были записаны в stdout
   146 000000E8 750D                        jnz exit_with_error
   147 000000EA C3                          ret
   148                                  ; --- write_stdout ---
   149                                  
   150                                  ; Выход
   151                                  exit:
   152 000000EB B83C000000                  mov rax, 60
   153 000000F0 BF00000000                  mov rdi, 0                  ; Возвращаем 0 при успешном завершении
   154 000000F5 0F05                        syscall
   155                                  
   156                                  ; Выход из программы с ошибкой
   157                                  exit_with_error:
   158 000000F7 B801000000                  mov rax, 1
   159 000000FC BF02000000                  mov rdi, 2
   160 00000101 48BE-                       mov rsi, err_critical_problem
   160 00000103 [4C00000000000000] 
   161 0000010B BA52000000                  mov rdx, err_critical_problem_len
   162 00000110 0F05                        syscall
   163                                  
   164 00000112 B83C000000                  mov rax, 60
   165 00000117 BF01000000                  mov rdi, 1
   166 0000011C 0F05                        syscall
