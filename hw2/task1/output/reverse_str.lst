     1                                  bits 64
     2                                  default rel
     3                                  global _start
     4                                  
     5                                  section .data
     6 00000000 577269746520736F6D-         write_msg db "Write some string: ", 0
     6 00000009 6520737472696E673A-
     6 00000012 2000               
     7                                      write_msg_len  equ $ - write_msg
     8 00000014 52657665727365643A-         reversed_msg db "Reversed: ", 0
     8 0000001D 2000               
     9                                      reversed_msg_len equ $ - reversed_msg
    10 0000001F 537472696E67207368-         err_empty_str db "String should contain at least one character, try again", 10
    10 00000028 6F756C6420636F6E74-
    10 00000031 61696E206174206C65-
    10 0000003A 617374206F6E652063-
    10 00000043 68617261637465722C-
    10 0000004C 207472792061676169-
    10 00000055 6E0A               
    11                                      err_empty_str_len equ $ - err_empty_str
    12 00000057 50726F6772616D2065-         err_critical_problem db "Program encountered critical error during read_stdin, flip_string or write_stdout", 10
    12 00000060 6E636F756E74657265-
    12 00000069 642063726974696361-
    12 00000072 6C206572726F722064-
    12 0000007B 7572696E6720726561-
    12 00000084 645F737464696E2C20-
    12 0000008D 666C69705F73747269-
    12 00000096 6E67206F7220777269-
    12 0000009F 74655F7374646F7574-
    12 000000A8 0A                 
    13                                      err_critical_problem_len equ $ - err_critical_problem
    14                                  
    15                                  section .bss
    16 00000000 <res 400h>                  input resb 1024             ; 1KB массив для входных данных
    17 00000400 <res 400h>                  reversed_str resb 1024      ; 1KB массив для "перевернутой" строки
    18                                  
    19                                  section .text
    20                                  _start:
    21 00000000 48BB-                       mov rbx, input                  ; Передаем указатель на массив, куда попадет исходная строка
    21 00000002 [0000000000000000] 
    22 0000000A B900040000                  mov rcx, 1024                   ; Передаем размер этого массива
    23 0000000F E859000000                  call read_stdin                 ; Вызываем функцию чтения из stdin
    24                                  
    25 00000014 48BF-                       mov rdi, input                  ; Передаем указатель на массив, содержащий исходную строку
    25 00000016 [0000000000000000] 
    26 0000001E 48BE-                       mov rsi, reversed_str           ; Передаем указатель на массив, куда попадет перевернутая строка
    26 00000020 [0004000000000000] 
    27 00000028 4889C2                      mov rdx, rax                    ; Передаем размер исходной строки
    28                                  
    29 0000002B 41B900040000                mov r9, 1024                    ; Передаем размер reversed_std
    30 00000031 4989C2                      mov r10, rax                    ; Сохраняем размер исходной строки
    31                                  
    32 00000034 E883000000                  call flip_string                ; Вызываем функцию "переворота" строки
    33                                      
    34 00000039 4939C2                      cmp r10, rax                    ; Проверяем, что "переворот" строки прошел успешно
    35 0000003C 0F85DD000000                jnz exit_with_error
    36                                  
    37 00000042 48BE-                       mov rsi, reversed_msg           ; Выводим сообщение "Reversed: "
    37 00000044 [1400000000000000] 
    38 0000004C BA0B000000                  mov rdx, reversed_msg_len
    39 00000051 E8AB000000                  call write_stdout
    40                                  
    41 00000056 48BE-                       mov rsi, reversed_str           ; Выводим полученную строку 
    41 00000058 [0004000000000000] 
    42 00000060 4C89D2                      mov rdx, r10
    43 00000063 E899000000                  call write_stdout
    44                                  
    45 00000068 E9A6000000                  jmp exit
    46                                  
    47                                  ; --- read_stdin ---
    48                                  ; @brief    Фукнция для чтения из stdin
    49                                  ; @param    rbx - указатель на массив, в который будут записаны данные
    50                                  ; @param    rcx - размер переданного массива
    51                                  ; @return   rax - размер записанных в массив данных
    52                                  ; @note     Аналог на Си: int read_stdin(char* input, size_t input_size)
    53                                  ; @note     Проверяет rax на содержание кода ошибки (отрицательное число) после
    54                                  ; @note     чтения из stdin
    55                                  read_stdin:
    56 0000006D 48BE-                       mov rsi, write_msg              ; Выводим сообщение о необходимости ввести строку
    56 0000006F [0000000000000000] 
    57 00000077 BA14000000                  mov rdx, write_msg_len
    58 0000007C E880000000                  call write_stdout    
    59                                  
    60 00000081 B800000000                  mov rax, 0                      ; 0 - sys_read
    61 00000086 BF00000000                  mov rdi, 0                      ; 0 - stdin
    62 0000008B 4889DE                      mov rsi, rbx                    ; передаем указатель на массив, в который попадут введенные данные
    63 0000008E 4889CA                      mov rdx, rcx 
    64 00000091 0F05                        syscall
    65                                  
    66 00000093 4885C0                      test rax, rax                   ; Проверка на корректное вовзращенное значение (>=0)
    67 00000096 0F8883000000                js exit_with_error
    68                                  
    69 0000009C 803D(00000000)0A            cmp byte [input], 0x0A          ; Проверка на строку, стостоящую только из перевода каретки 
    70 000000A3 7401                        je empty_string_warning         ; Переход, если первый знак в input == 0x0A
    71                                  
    72 000000A5 C3                          ret
    73                                  
    74                                  ; Сообщение о пустой строке
    75                                  empty_string_warning:
    76 000000A6 48BE-                       mov rsi, err_empty_str          ; Передаем указатель на строку с информацей об ошибке 
    76 000000A8 [1F00000000000000] 
    77 000000B0 BA38000000                  mov rdx, err_empty_str_len      ; Передаем ее длину
    78                                      
    79 000000B5 E847000000                  call write_stdout               ; Вызываем функцию записи в stdout
    80                                  
    81 000000BA EBB1                        jmp read_stdin                  ; Повторяем попытку получить корректную строку от пользователя
    82                                  ; --- read_stdin ---
    83                                  
    84                                  ; --- flip_string ---
    85                                  ; @brief    Фукнция для "переворота" строки
    86                                  ; @param    rdi - указатель на массив исходных данных
    87                                  ; @param    rsi - указатель на массив, куда будет записана "перевенутая" строка
    88                                  ; @param    rdx - размер исходных данных
    89                                  ; @param    r9  - размер массива для записи данных (rsi)
    90                                  ; @return   rax - размер записанных в массив, переданный в rsi, данных
    91                                  ; @note     Аналог на Си: int flip_string(char* input, char* output, size_t input_size)
    92                                  ; @note     Если rdx < 1 возвращает код ошибки -1
    93                                  ; @note     Если размер исходных занных больше размера массива для записи
    94                                  ; @note     данных, возвращаемт код ошибки -2 
    95                                  
    96                                  ; Инициализация необходимых значений
    97                                  flip_string:
    98 000000BC 4883FA01                    cmp rdx, 1                      ; Если размер исходных данных меньше 1
    99 000000C0 7C2F                        jl exit_flip_string_with_error  ; выходим с ошибкой
   100                                  
   101 000000C2 4C39CA                      cmp rdx, r9                     ; Если размер исходных данных больше размера
   102 000000C5 7F32                        jg exit_flip_string_overflow    ; массива, куда будут попадать "перевернутые" данные, выходим с ошибкой
   103                                  
   104 000000C7 4889D1                      mov rcx, rdx                    ; Инициализируем счетчик, который будет указывать на текущий последний знак в строке
   105 000000CA 48FFC9                      dec rcx                         ; Пропускаем перевод каретки
   106 000000CD 4D31C9                      xor r9, r9                      ; обнуляем r9, так как будем исользовать
   107                                                                      ; его в качестве счетчика обработанный байт
   108                                  
   109                                  ; "Переворот" данных
   110                                  flip_string_loop:
   111 000000D0 48FFC9                      dec rcx                         ; уменьшаем счетчик, который указывает на конец input
   112 000000D3 780C                        js end_flip_string              ; если он стал отрицательным, значит инвесия закончена - выходим
   113                                  
   114 000000D5 8A040F                      mov al, [rdi + rcx]             ; Получаем последний знак на данный момент 
   115                                                                      ; al - младший байт регистра RAX, в данном случае необходим, так как данные длиной 1 байт 
   116 000000D8 4288040E                    mov [rsi + r9], al              ; помещаем последний знак в начало reversed_str
   117 000000DC 49FFC1                      inc r9
   118                                  
   119 000000DF EBEF                        jmp flip_string_loop            ; Повторяем, пока не обработаем все знаки
   120                                  
   121                                  ; Вставка перевода каретки в конец перевернутой строки
   122                                  end_flip_string: 
   123 000000E1 B00A                        mov al, 10
   124 000000E3 418881[00040000]            mov [reversed_str + r9], al     ; Перевод каретки
   125 000000EA 49FFC1                      inc r9
   126                                  
   127 000000ED 4C89C8                      mov rax, r9
   128                                  
   129 000000F0 C3                          ret
   130                                  
   131                                  exit_flip_string_with_error:
   132 000000F1 48C7C0FFFFFFFF              mov rax, -1
   133 000000F8 C3                          ret
   134                                  
   135                                  exit_flip_string_overflow:
   136 000000F9 48C7C0FEFFFFFF              mov rax, -2
   137 00000100 C3                          ret
   138                                  ; --- flip_string ---
   139                                  
   140                                  ; --- write_stdout ---
   141                                  ; @brief    Фукнция для записи в stdout
   142                                  ; @param    r9 - указатель на буфер, из которого будут извлечены данные
   143                                  ; @param    r10 - количество байт, которые необходимо записать в stdout
   144                                  ; @return   rax - размер записанных в stdout данных
   145                                  ; @note     Аналог на Си: int write_stdout(char* data, size_t input_size)
   146                                  ; @note     Проверяет rax на соответствие r9 после записи в stdout
   147                                  write_stdout:
   148 00000101 B801000000                  mov rax, 1                      ; 1 - sys_write
   149 00000106 BF01000000                  mov rdi, 1                      ; 1 - stdout
   150 0000010B 0F05                        syscall
   151                                  
   152 0000010D 4839C2                      cmp rdx, rax                    ; Проверить, что все данные были записаны в stdout
   153 00000110 750D                        jnz exit_with_error
   154 00000112 C3                          ret
   155                                  ; --- write_stdout ---
   156                                  
   157                                  ; Выход
   158                                  exit:
   159 00000113 B83C000000                  mov rax, 60
   160 00000118 BF00000000                  mov rdi, 0                  ; Возвращаем 0 при успешном завершении
   161 0000011D 0F05                        syscall
   162                                  
   163                                  ; Выход из программы с ошибкой
   164                                  exit_with_error:
   165 0000011F B801000000                  mov rax, 1
   166 00000124 BF02000000                  mov rdi, 2
   167 00000129 48BE-                       mov rsi, err_critical_problem
   167 0000012B [5700000000000000] 
   168 00000133 BA52000000                  mov rdx, err_critical_problem_len
   169 00000138 0F05                        syscall
   170                                  
   171 0000013A B83C000000                  mov rax, 60
   172 0000013F BF01000000                  mov rdi, 1
   173 00000144 0F05                        syscall
