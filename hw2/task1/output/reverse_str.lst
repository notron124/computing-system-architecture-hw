     1                                  bits 64
     2                                  default rel
     3                                  global _start
     4                                  
     5                                  section .data
     6 00000000 577269746520736F6D-         write_msg db "Write some string: ", 0
     6 00000009 6520737472696E673A-
     6 00000012 2000               
     7                                      write_msg_len  equ $ - write_msg
     8 00000014 52657665727365643A-         reversed_msg db "Reversed: ", 0
     8 0000001D 2000               
     9                                      reversed_msg_len equ $ - reversed_msg
    10 0000001F 537472696E67207368-         err_empty_str db "String should contain at least one character, try again", 10
    10 00000028 6F756C6420636F6E74-
    10 00000031 61696E206174206C65-
    10 0000003A 617374206F6E652063-
    10 00000043 68617261637465722C-
    10 0000004C 207472792061676169-
    10 00000055 6E0A               
    11                                      err_empty_str_len equ $ - err_empty_str
    12 00000057 50726F6772616D2065-         err_critical_problem db "Program encountered critical error during read_stdin, flip_string or write_stdout", 10
    12 00000060 6E636F756E74657265-
    12 00000069 642063726974696361-
    12 00000072 6C206572726F722064-
    12 0000007B 7572696E6720726561-
    12 00000084 645F737464696E2C20-
    12 0000008D 666C69705F73747269-
    12 00000096 6E67206F7220777269-
    12 0000009F 74655F7374646F7574-
    12 000000A8 0A                 
    13                                      err_critical_problem_len equ $ - err_critical_problem
    14                                  
    15                                  section .bss
    16 00000000 <res 400h>                  input resb 1024             ; 1KB массив для входных данных
    17 00000400 <res 400h>                  reversed_str resb 1024      ; 1KB массив для "перевернутой" строки
    18                                  
    19                                                                      ; По поводу проблемы с неизвестным разамером
    20                                                                      ; входных данных: в данной задаче
    21                                                                      ; оптимальнее всего использовать заведомо
    22                                                                      ; достаточный буффер, то-есть явно указать в
    23                                                                      ; условной документации максимальный размер
    24                                                                      ; строки. Если все же необходимо читать
    25                                                                      ; строку "бесконечной" (сколько памяти,
    26                                                                      ; столько и длина) длины то вот мои решения: 
    27                                                                      ; Решение №1: читать по 1 байту и сразу
    28                                                                      ; как-то обрабатывать, в частности
    29                                                                      ; реализовать LIFO, то-есть в итоге строку
    30                                                                      ; даже не нужно будет явно переворачивать
    31                                                                      ; между буфферами.
    32                                                                      ; Решение №2: Читать "чанками" по n
    33                                                                      ; байт, при необходимости увеличивать
    34                                                                      ; буффер.
    35                                                                      ; (Оба решения - динамическя аллокация, опасно, сложно)
    36                                  section .text
    37                                  _start:
    38 00000000 48BB-                       mov rbx, input                  ; Передаем указатель на массив, куда попадет исходная строка
    38 00000002 [0000000000000000] 
    39 0000000A B900040000                  mov rcx, 1024                   ; Передаем размер этого массива
    40 0000000F E859000000                  call read_stdin                 ; Вызываем функцию чтения из stdin
    41                                  
    42 00000014 48BF-                       mov rdi, input                  ; Передаем указатель на массив, содержащий исходную строку
    42 00000016 [0000000000000000] 
    43 0000001E 48BE-                       mov rsi, reversed_str           ; Передаем указатель на массив, куда попадет перевернутая строка
    43 00000020 [0004000000000000] 
    44 00000028 4889C2                      mov rdx, rax                    ; Передаем размер исходной строки
    45                                  
    46 0000002B 41B900040000                mov r9, 1024                    ; Передаем размер reversed_std
    47 00000031 4989C2                      mov r10, rax                    ; Сохраняем размер исходной строки
    48                                  
    49 00000034 E889000000                  call flip_string                ; Вызываем функцию "переворота" строки
    50                                      
    51 00000039 4939C2                      cmp r10, rax                    ; Проверяем, что "переворот" строки прошел успешно
    52 0000003C 0F85E3000000                jnz exit_with_error
    53                                  
    54 00000042 48BE-                       mov rsi, reversed_msg           ; Выводим сообщение "Reversed: "
    54 00000044 [1400000000000000] 
    55 0000004C BA0B000000                  mov rdx, reversed_msg_len
    56 00000051 E8B1000000                  call write_stdout
    57                                  
    58 00000056 48BE-                       mov rsi, reversed_str           ; Выводим полученную строку 
    58 00000058 [0004000000000000] 
    59 00000060 4C89D2                      mov rdx, r10
    60 00000063 E89F000000                  call write_stdout
    61                                  
    62 00000068 E9AC000000                  jmp exit
    63                                  
    64                                  ; --- read_stdin ---
    65                                  ; @brief    Фукнция для чтения из stdin
    66                                  ; @param    rbx - указатель на массив, в который будут записаны данные
    67                                  ; @param    rcx - размер переданного массива
    68                                  ; @return   rax - размер записанных в массив данных
    69                                  ; @note     Аналог на Си: int read_stdin(char* input, size_t input_size)
    70                                  ; @note     Проверяет rax на содержание кода ошибки (отрицательное число) после
    71                                  ; @note     чтения из stdin
    72                                  read_stdin:
    73 0000006D 4989C8                      mov r8, rcx                     ; Сохранить rcx (rcx будет задействован в sys_write)
    74 00000070 48BE-                       mov rsi, write_msg              ; Выводим сообщение о необходимости ввести строку
    74 00000072 [0000000000000000] 
    75 0000007A BA14000000                  mov rdx, write_msg_len
    76 0000007F E883000000                  call write_stdout    
    77 00000084 4C89C1                      mov rcx, r8                     ; Восстановить rcx
    78                                  
    79 00000087 B800000000                  mov rax, 0                      ; 0 - sys_read
    80 0000008C BF00000000                  mov rdi, 0                      ; 0 - stdin
    81 00000091 4889DE                      mov rsi, rbx                    ; передаем указатель на массив, в который попадут введенные данные
    82 00000094 4889CA                      mov rdx, rcx 
    83 00000097 0F05                        syscall
    84                                  
    85 00000099 4885C0                      test rax, rax                   ; Проверка на корректное вовзращенное значение (>=0)
    86 0000009C 0F8883000000                js exit_with_error
    87                                  
    88 000000A2 803D(00000000)0A            cmp byte [input], 0x0A          ; Проверка на строку, стостоящую только из перевода каретки 
    89 000000A9 7401                        je empty_string_warning         ; Переход, если первый знак в input == 0x0A
    90                                  
    91 000000AB C3                          ret
    92                                  
    93                                  ; Сообщение о пустой строке
    94                                  empty_string_warning:
    95 000000AC 48BE-                       mov rsi, err_empty_str          ; Передаем указатель на строку с информацей об ошибке 
    95 000000AE [1F00000000000000] 
    96 000000B6 BA38000000                  mov rdx, err_empty_str_len      ; Передаем ее длину 
    97 000000BB E847000000                  call write_stdout               ; Вызываем функцию записи в stdout
    98                                  
    99 000000C0 EBAB                        jmp read_stdin                  ; Повторяем попытку получить корректную строку от пользователя
   100                                  ; --- read_stdin ---
   101                                  
   102                                  ; --- flip_string ---
   103                                  ; @brief    Фукнция для "переворота" строки
   104                                  ; @param    rdi - указатель на массив исходных данных
   105                                  ; @param    rsi - указатель на массив, куда будет записана "перевенутая" строка
   106                                  ; @param    rdx - размер исходных данных
   107                                  ; @param    r9  - размер массива для записи данных (rsi)
   108                                  ; @return   rax - размер записанных в массив, переданный в rsi, данных
   109                                  ; @note     Аналог на Си: int flip_string(char* input, char* output, size_t input_size)
   110                                  ; @note     Если rdx < 1 возвращает код ошибки -1
   111                                  ; @note     Если размер исходных занных больше размера массива для записи
   112                                  ; @note     данных, возвращаемт код ошибки -2 
   113                                  
   114                                  ; Инициализация необходимых значений
   115                                  flip_string:
   116 000000C2 4883FA01                    cmp rdx, 1                      ; Если размер исходных данных меньше 1
   117 000000C6 7C2F                        jl exit_flip_string_with_error  ; выходим с ошибкой
   118                                  
   119 000000C8 4C39CA                      cmp rdx, r9                     ; Если размер исходных данных больше размера
   120 000000CB 7F32                        jg exit_flip_string_overflow    ; массива, куда будут попадать "перевернутые" данные, выходим с ошибкой
   121                                  
   122 000000CD 4889D1                      mov rcx, rdx                    ; Инициализируем счетчик, который будет указывать на текущий последний знак в строке
   123 000000D0 48FFC9                      dec rcx                         ; Пропускаем перевод каретки
   124 000000D3 4D31C9                      xor r9, r9                      ; обнуляем r9, так как будем исользовать
   125                                                                      ; его в качестве счетчика обработанный байт
   126                                  
   127                                  ; "Переворот" данных
   128                                  flip_string_loop:
   129 000000D6 48FFC9                      dec rcx                         ; уменьшаем счетчик, который указывает на конец input
   130 000000D9 780C                        js end_flip_string              ; если он стал отрицательным, значит инвесия закончена - выходим
   131                                  
   132 000000DB 8A040F                      mov al, [rdi + rcx]             ; Получаем последний знак на данный момент 
   133                                                                      ; al - младший байт регистра RAX, в данном случае необходим, так как данные длиной 1 байт 
   134 000000DE 4288040E                    mov [rsi + r9], al              ; помещаем последний знак в начало reversed_str
   135 000000E2 49FFC1                      inc r9
   136                                  
   137 000000E5 EBEF                        jmp flip_string_loop            ; Повторяем, пока не обработаем все знаки
   138                                  
   139                                  ; Вставка перевода каретки в конец перевернутой строки
   140                                  end_flip_string: 
   141 000000E7 B00A                        mov al, 10
   142 000000E9 418881[00040000]            mov [reversed_str + r9], al     ; Перевод каретки
   143 000000F0 49FFC1                      inc r9
   144                                  
   145 000000F3 4C89C8                      mov rax, r9
   146                                  
   147 000000F6 C3                          ret
   148                                  
   149                                  exit_flip_string_with_error:
   150 000000F7 48C7C0FFFFFFFF              mov rax, -1
   151 000000FE C3                          ret
   152                                  
   153                                  exit_flip_string_overflow:
   154 000000FF 48C7C0FEFFFFFF              mov rax, -2
   155 00000106 C3                          ret
   156                                  ; --- flip_string ---
   157                                  
   158                                  ; --- write_stdout ---
   159                                  ; @brief    Фукнция для записи в stdout
   160                                  ; @param    r9 - указатель на буфер, из которого будут извлечены данные
   161                                  ; @param    r10 - количество байт, которые необходимо записать в stdout
   162                                  ; @return   rax - размер записанных в stdout данных
   163                                  ; @note     Аналог на Си: int write_stdout(char* data, size_t input_size)
   164                                  ; @note     Проверяет rax на соответствие r9 после записи в stdout
   165                                  write_stdout:
   166 00000107 B801000000                  mov rax, 1                      ; 1 - sys_write
   167 0000010C BF01000000                  mov rdi, 1                      ; 1 - stdout
   168 00000111 0F05                        syscall
   169                                  
   170 00000113 4839C2                      cmp rdx, rax                    ; Проверить, что все данные были записаны в stdout
   171 00000116 750D                        jnz exit_with_error
   172 00000118 C3                          ret
   173                                  ; --- write_stdout ---
   174                                  
   175                                  ; Выход
   176                                  exit:
   177 00000119 B83C000000                  mov rax, 60
   178 0000011E BF00000000                  mov rdi, 0                  ; Возвращаем 0 при успешном завершении
   179 00000123 0F05                        syscall
   180                                  
   181                                  ; Выход из программы с ошибкой
   182                                  exit_with_error:
   183 00000125 B801000000                  mov rax, 1
   184 0000012A BF02000000                  mov rdi, 2
   185 0000012F 48BE-                       mov rsi, err_critical_problem
   185 00000131 [5700000000000000] 
   186 00000139 BA52000000                  mov rdx, err_critical_problem_len
   187 0000013E 0F05                        syscall
   188                                  
   189 00000140 B83C000000                  mov rax, 60
   190 00000145 BF01000000                  mov rdi, 1
   191 0000014A 0F05                        syscall
