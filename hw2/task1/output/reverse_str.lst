     1                                  bits 64
     2                                  default rel
     3                                  global _start
     4                                  
     5                                  section .data
     6 00000000 577269746520736F6D-         write_msg db "Write some string: ", 0
     6 00000009 6520737472696E673A-
     6 00000012 2000               
     7                                      write_msg_len  equ $ - write_msg
     8 00000014 537472696E67207368-         err_empty_str db "String should contain at least one character, try again", 10   ; Добавить краткое описание ошибок
     8 0000001D 6F756C6420636F6E74-
     8 00000026 61696E206174206C65-
     8 0000002F 617374206F6E652063-
     8 00000038 68617261637465722C-
     8 00000041 207472792061676169-
     8 0000004A 6E0A               
     9                                      err_empty_str_len equ $ - err_empty_str
    10                                  
    11                                  section .bss
    12 00000000 <res 400h>                  input resb 1024             ; 1KB буффер для входных данных
    13 00000400 <res 400h>                  reversed_str resb 1024      ; 1KB буффер для "перевернутой" строки
    14                                  
    15                                  section .text
    16                                  _start:
    17 00000000 48BB-                       mov rbx, input
    17 00000002 [0000000000000000] 
    18 0000000A B900040000                  mov rcx, 1024
    19 0000000F E833000000                  call read_stdin
    20                                  
    21 00000014 48BF-                       mov rdi, input                  ; Передаем указатель на массив, содержащий исходную строку
    21 00000016 [0000000000000000] 
    22 0000001E 48BE-                       mov rsi, reversed_str           ; Передаем указатель на массив, куда попадет перевернутая строка
    22 00000020 [0004000000000000] 
    23 00000028 4889C2                      mov rdx, rax                    ; Передаем размер исходной строки
    24                                      
    25 0000002B 4989C1                      mov r9, rax                     ; Сохраняем размер исходной строки
    26                                  
    27 0000002E E84B000000                  call flip_string
    28                                      
    29                                      ;cmp r9, rax
    30                                      ;jnz exit_with_error
    31                                  
    32 00000033 48BE-                       mov rsi, reversed_str
    32 00000035 [0004000000000000] 
    33 0000003D 4889C2                      mov rdx, rax
    34                                  
    35 00000040 E86B000000                  call write_stdout
    36                                  
    37 00000045 EB7B                        jmp exit
    38                                  
    39                                  ; --- read_stdin ---
    40                                  ; @brief    Фукнция для чтения из stdin
    41                                  ; @param    rbx - указатель на буфер, в который будут записаны данные
    42                                  ; @param    rcx - размер переданного буфера
    43                                  ; @return   rax - размер записанных в буфер данных
    44                                  ; @note     Аналог на Си: int read_stdin(char* input, size_t input_size)
    45                                  ; @note     Проверяет rax на содержание кода ошибки (отрицательное число) после
    46                                  ; @note     чтения из stdin
    47                                  read_stdin:
    48 00000047 B800000000                  mov rax, 0                      ; 0 - sys_read
    49 0000004C BF00000000                  mov rdi, 0                      ; 0 - stdin
    50 00000051 4889DE                      mov rsi, rbx                    ; передаем указатель на массив, в который попадут введенные данные
    51 00000054 4889CA                      mov rdx, rcx 
    52 00000057 0F05                        syscall
    53                                  
    54 00000059 4885C0                      test rax, rax                   ; Проверка на корректное вовзращенное значение (>=0)
    55 0000005C 7870                        js exit_with_error
    56                                  
    57 0000005E 803D(00000000)0A            cmp byte [input], 0x0A          ; Проверка на строку, стостоящую только из перевода каретки 
    58 00000065 7401                        je empty_string_warning         ; Переход, если первый знак в input == 0x0A
    59                                  
    60 00000067 C3                          ret
    61                                  
    62                                  ; Сообщение о пустой строке
    63                                  empty_string_warning:
    64 00000068 48BE-                       mov rsi, err_empty_str           ; Передаем указатель на строку с информацтей об ошибке 
    64 0000006A [1400000000000000] 
    65 00000072 BA38000000                  mov rdx, err_empty_str_len      ; Передаем ее длину
    66                                      
    67 00000077 E834000000                  call write_stdout               ; Вызываем функцию записи в stdout
    68                                  
    69 0000007C EBC9                        jmp read_stdin                  ; Повторяем попытку получить корректную строку от пользователя
    70                                  ; --- read_stdin ---
    71                                  
    72                                  ; --- flip_string ---
    73                                  ; Инициализация необходимых значений
    74                                  flip_string:
    75                                      ;cmp rdx, 1                      ; Если размер переданных данных меньше 1
    76                                      ;jl exit_flip_string_with_error  ; выходим с ошибкой
    77                                  
    78 0000007E 4889D1                      mov rcx, rdx                    ; Инициализируем счетчик, который будет указывать на текущий последний знак в строке
    79 00000081 48FFC9                      dec rcx                         ; Пропускаем перевод каретки
    80 00000084 4D31C9                      xor r9, r9                      ; обнуляем r9, так как будем исользовать
    81                                                                      ; его в качестве счетчика обработанный байт
    82                                  
    83                                  ; "Переворот" данных
    84                                  flip_string_loop:
    85 00000087 48FFC9                      dec rcx                         ; уменьшаем счетчик, который указывает на конец input
    86 0000008A 780C                        js end_flip_string              ; если он стал отрицательным, значит инвесия закончена - выходим
    87                                  
    88 0000008C 8A040F                      mov al, [rdi + rcx]             ; Получаем последний знак на данный момент 
    89                                                                      ; al - младший байт регистра RAX, в данном случае необходим, так как данные длиной 1 байт 
    90 0000008F 4288040E                    mov [rsi + r9], al             ; помещаем последний знак в начало reversed_str
    91 00000093 49FFC1                      inc r9
    92                                  
    93 00000096 EBEF                        jmp flip_string_loop            ; Повторяем, пока не обработаем все знаки
    94                                  
    95                                  ; Вставка перевода каретки в конец перевернутой строки
    96                                  end_flip_string: 
    97 00000098 B00A                        mov al, 10
    98 0000009A 418881[00040000]            mov [reversed_str + r9], al     ; Перевод каретки
    99 000000A1 49FFC1                      inc r9
   100                                  
   101 000000A4 4C89C8                      mov rax, r9
   102                                  
   103 000000A7 C3                          ret
   104                                  
   105                                  exit_flip_string_with_error:
   106 000000A8 48C7C0FFFFFFFF              mov rax, -1
   107 000000AF C3                          ret
   108                                  ; --- flip_string ---
   109                                  
   110                                  ; --- write_stdout ---
   111                                  ; @brief    Фукнция для записи в stdout
   112                                  ; @param    r9 - указатель на буфер, из которого будут извлечены данные
   113                                  ; @param    r10 - количество байт, которые необходимо записать в stdout
   114                                  ; @return   rax - размер записанных в stdout данных
   115                                  ; @note     Аналог на Си: int write_stdout(char* data, size_t input_size)
   116                                  ; @note     Проверяет rax на соответствие r9 после записи в stdout
   117                                  write_stdout:
   118 000000B0 B801000000                  mov rax, 1                      ; 1 - sys_write
   119 000000B5 BF01000000                  mov rdi, 1                      ; 1 - stdout
   120 000000BA 0F05                        syscall
   121                                  
   122 000000BC 4839C2                      cmp rdx, rax                    ; Проверить, что все данные были записаны в stdout
   123 000000BF 750D                        jnz exit_with_error
   124 000000C1 C3                          ret
   125                                  ; --- write_stdout ---
   126                                  
   127                                  ; Выход
   128                                  exit:
   129 000000C2 B83C000000                  mov rax, 60
   130 000000C7 BF00000000                  mov rdi, 0                  ; Возвращаем 0 при успешном завершении
   131 000000CC 0F05                        syscall
   132                                  
   133                                  ; Выход из программы с ошибкой
   134                                  exit_with_error:
   135                                      ; mov rax, 1
   136                                      ; mov rdi, 2
   137                                      ; mov rsi, err_msg
   138                                      ; mov rdx, err_msg_len
   139                                      ; syscall
   140                                  
   141 000000CE B83C000000                  mov rax, 60
   142 000000D3 BF01000000                  mov rdi, 1
   143 000000D8 0F05                        syscall
