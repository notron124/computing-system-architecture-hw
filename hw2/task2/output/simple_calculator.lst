     1                                  bits 64
     2                                  default rel
     3                                  global _start
     4                                  
     5                                  section .data
     6 00000000 00                          char_to_print db 0
     7 00000001 577269746520736F6D-         write_msg db "Write some number: ", 0
     7 0000000A 65206E756D6265723A-
     7 00000013 2000               
     8                                      write_msg_len  equ $ - write_msg
     9 00000015 202B2000                    plus_msg db " + ", 0
    10                                      plus_msg_len equ $ - plus_msg
    11 00000019 203D2000                    equals_msg db " = ", 0
    12                                      equals_msg_len equ $ - equals_msg
    13 0000001D 496E7075742073686F-         err_empty_str db "Input should contain atleast one digit, please try again", 10
    13 00000026 756C6420636F6E7461-
    13 0000002F 696E2061746C656173-
    13 00000038 74206F6E6520646967-
    13 00000041 69742C20706C656173-
    13 0000004A 652074727920616761-
    13 00000053 696E0A             
    14                                      err_empty_str_len equ $ - err_empty_str
    15 00000056 206973206E6F742061-         err_wrong_char db " is not a decimal digit, try again", 10
    15 0000005F 20646563696D616C20-
    15 00000068 64696769742C207472-
    15 00000071 7920616761696E0A   
    16                                      err_wrong_char_len equ $ - err_wrong_char
    17 00000079 50726F6772616D2065-         err_critical_problem db "Program encountered critical error during read_stdin, number conversion, summ or write_stdout", 10
    17 00000082 6E636F756E74657265-
    17 0000008B 642063726974696361-
    17 00000094 6C206572726F722064-
    17 0000009D 7572696E6720726561-
    17 000000A6 645F737464696E2C20-
    17 000000AF 6E756D62657220636F-
    17 000000B8 6E76657273696F6E2C-
    17 000000C1 2073756D6D206F7220-
    17 000000CA 77726974655F737464-
    17 000000D3 6F75740A           
    18                                      err_critical_problem_len equ $ - err_critical_problem
    19                                  
    20                                  section .bss
    21 00000000 <res 400h>                  input resb      1024           ; 1KB массив для входных данных
    22 00000400 0000000000000000            first_number    dq      0      ; 64bit переменная для хранения первого числа
    22          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    23 00000408 0000000000000000            second_number   dq      0      ; 64bit переменная для хранения второго числа
    23          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    24 00000410 0000000000000000            sum             dq      0      ; 64bit переменная для суммы двух чисел
    24          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    25 00000418 <res 400h>                  output resb     1024           ; 1KB массив для выходных данных
    26                                  
    27                                  section .text
    28                                  _start:
    29 00000000 48BB-                       mov rbx, input                  ; Передаем указатель на массив, куда попадет исходная строка
    29 00000002 [0000000000000000] 
    30 0000000A B900040000                  mov rcx, 1024                   ; Передаем размер этого массива
    31 0000000F E844010000                  call read_stdin                 ; Вызываем функцию чтения из stdin
    32                                  
    33 00000014 48BF-                       mov rdi, input                  ; Передаем указатель на массив, содержащий число в виде строки
    33 00000016 [0000000000000000] 
    34                                      
    35 0000001E E886010000                  call stoi64                     ; Вызываем функцию "переворота" строки
    36                                  
    37 00000023 488905(00040000)            mov [first_number], rax         ; Сохраняем первое число в переменную
    38                                  
    39 0000002A 48BB-                       mov rbx, input                  ; Читаем второе число
    39 0000002C [0000000000000000] 
    40 00000034 B900040000                  mov rcx, 1024
    41 00000039 E81A010000                  call read_stdin
    42                                  
    43 0000003E 48BF-                       mov rdi, input                  ; Конвертируем второе число
    43 00000040 [0000000000000000] 
    44 00000048 E85C010000                  call stoi64
    45                                  
    46 0000004D 488905(08040000)            mov [second_number], rax        ; Сохраняем его
    47                                  
    48 00000054 488B3D(00040000)            mov rdi, [first_number]         ; Передаем первое число в функцию сложения
    49 0000005B 488B35(08040000)            mov rsi, [second_number]        ; Передаем второе число в функцию сложения
    50                                  
    51 00000062 E859020000                  call sum_of_two                 ; Вызываем функцию складывания
    52                                  
    53 00000067 488905(10040000)            mov [sum], rax
    54                                      
    55 0000006E 488B3D(00040000)            mov rdi, [first_number]         ; Передаем значение переменной
    56 00000075 48BE-                       mov rsi, output                 ; Передаем указатель на массив, куда попадет строка 
    56 00000077 [1804000000000000] 
    57 0000007F BA00040000                  mov rdx, 1024                   ; Длина переданного массива для проверки на overflow
    58 00000084 E8A5010000                  call itos64
    59                                  
    60 00000089 4885C0                      test rax, rax                   ; Проверка на отсутствие ошибки
    61 0000008C 0F8853020000                js exit_with_error
    62                                  
    63 00000092 48BE-                       mov rsi, output                 ; Выводим первое число
    63 00000094 [1804000000000000] 
    64 0000009C 4889C2                      mov rdx, rax
    65 0000009F E823020000                  call write_stdout
    66                                  
    67 000000A4 48BE-                       mov rsi, plus_msg               ; Выводим знак +
    67 000000A6 [1500000000000000] 
    68 000000AE BA04000000                  mov rdx, plus_msg_len
    69 000000B3 E80F020000                  call write_stdout
    70                                  
    71 000000B8 488B3D(08040000)            mov rdi, [second_number]        ; Конвертируем второе число в строку
    72 000000BF 48BE-                       mov rsi, output
    72 000000C1 [1804000000000000] 
    73 000000C9 BA00040000                  mov rdx, 1024
    74 000000CE E85B010000                  call itos64
    75                                  
    76 000000D3 4885C0                      test rax, rax                   ; Проверяем на отсутствие ошибки
    77 000000D6 0F8809020000                js exit_with_error
    78                                  
    79 000000DC 48BE-                       mov rsi, output                 ; Выводим второе число
    79 000000DE [1804000000000000] 
    80 000000E6 4889C2                      mov rdx, rax
    81 000000E9 E8D9010000                  call write_stdout
    82                                  
    83 000000EE 48BE-                       mov rsi, equals_msg             ; Выводим знак =
    83 000000F0 [1900000000000000] 
    84 000000F8 BA04000000                  mov rdx, equals_msg_len
    85 000000FD E8C5010000                  call write_stdout
    86                                  
    87 00000102 488B3D(10040000)            mov rdi, [sum]                  ; Конвертируем результат сложения
    88 00000109 48BE-                       mov rsi, output
    88 0000010B [1804000000000000] 
    89 00000113 BA00040000                  mov rdx, 1024
    90 00000118 E811010000                  call itos64
    91                                      
    92 0000011D 4885C0                      test rax, rax                   ; Проверяем на отсутствие ошибки
    93 00000120 0F88BF010000                js exit_with_error
    94                                      
    95 00000126 48BE-                       mov rsi, output                 ; Выводим сумму
    95 00000128 [1804000000000000] 
    96 00000130 4889C2                      mov rdx, rax
    97 00000133 E88F010000                  call write_stdout
    98                                  
    99 00000138 C605(00000000)0A            mov byte [char_to_print], 10
   100 0000013F 48BE-                       mov rsi, char_to_print
   100 00000141 [0000000000000000] 
   101 00000149 BA01000000                  mov rdx, 1
   102 0000014E E874010000                  call write_stdout
   103                                  
   104 00000153 E981010000                  jmp exit
   105                                  
   106                                  ; --- read_stdin ---
   107                                  ; @brief    Фукнция для чтения из stdin
   108                                  ; @param    rbx - указатель на массив, в который будут записаны данные
   109                                  ; @param    rcx - размер переданного массива
   110                                  ; @return   rax - размер записанных в массив данных
   111                                  ; @note     Аналог на Си: int read_stdin(char* input, size_t input_size)
   112                                  ; @note     Проверяет rax на содержание кода ошибки (отрицательное число) после
   113                                  ; @note     чтения из stdin
   114                                  read_stdin:
   115 00000158 51                          push rcx                        ; Сохранить rcx (rcx будет задействован в sys_write)
   116 00000159 48BE-                       mov rsi, write_msg              ; Выводим сообщение о необходимости ввести строку
   116 0000015B [0100000000000000] 
   117 00000163 BA14000000                  mov rdx, write_msg_len
   118 00000168 E85A010000                  call write_stdout    
   119 0000016D 59                          pop rcx                         ; Восстановить rcx
   120                                  
   121 0000016E B800000000                  mov rax, 0                      ; 0 - sys_read
   122 00000173 BF00000000                  mov rdi, 0                      ; 0 - stdin
   123 00000178 4889DE                      mov rsi, rbx                    ; передаем указатель на массив, в который попадут введенные данные
   124 0000017B 4889CA                      mov rdx, rcx 
   125 0000017E 0F05                        syscall
   126                                  
   127 00000180 4885C0                      test rax, rax                   ; Проверка на корректное вовзращенное значение (>=0)
   128 00000183 0F885C010000                js exit_with_error
   129                                  
   130 00000189 803D(00000000)0A            cmp byte [input], 0x0A          ; Проверка на строку, стостоящую только из перевода каретки 
   131 00000190 7401                        je empty_string_warning         ; Переход, если первый знак в input == 0x0A
   132                                  
   133 00000192 C3                          ret
   134                                  
   135                                  ; Сообщение о пустой строке
   136                                  empty_string_warning:
   137 00000193 48BE-                       mov rsi, err_empty_str          ; Передаем указатель на строку с информацей об ошибке 
   137 00000195 [1D00000000000000] 
   138 0000019D BA39000000                  mov rdx, err_empty_str_len      ; Передаем ее длину 
   139 000001A2 E820010000                  call write_stdout               ; Вызываем функцию записи в stdout
   140                                  
   141 000001A7 EBAF                        jmp read_stdin                  ; Повторяем попытку получить корректную строку от пользователя
   142                                  ; --- read_stdin ---
   143                                  
   144                                  ; --- stoi64 ---
   145                                  ; @brief    Фукнция для "переворота" строки
   146                                  ; @param    rdi - указатель на массив исходных данных
   147                                  ; @return   rax - строка переведенная в число
   148                                  ; @note     Аналог на Си: int stoi64(char* input)
   149                                  ; @note     Если в процессе парсинка встретилась не цифра, сообщает об этом и
   150                                  ; @note     возвращается к старту
   151                                  
   152                                  ; Инициализация необходимых значений
   153                                  stoi64:
   154 000001A9 4831C0                      xor rax, rax
   155 000001AC 4D31C0                      xor r8, r8
   156 000001AF 4D31C9                      xor r9, r9
   157                                      
   158 000001B2 428A0C07                    mov cl, [rdi + r8]              ; Проверяем первый знак на наличие '-' 
   159 000001B6 80F92D                      cmp cl, '-'
   160 000001B9 742A                        je stoi64_neg                  ; Переходим к конвертации отрицательного числа 
   161                                  
   162                                  stoi64_loop:
   163 000001BB 428A0C07                    mov cl, [rdi + r8]              ; Получаем текущий знак 
   164                                                                      ; cl - младший байт регистра RAX, в данном случае необходим, так как данные длиной 1 байт  
   165                                  
   166 000001BF 80F90A                      cmp cl, 10                      ; Проверяем на перевод каретки или нуль-терминатор
   167 000001C2 7E2D                        jle stoi64_end    
   168                                      
   169                                      ; Проверяем, что обрабатываем цифру, а не какой-либо другой знак
   170 000001C4 80F930                      cmp cl, '0'                     
   171 000001C7 7C32                        jl stoi64_err_exit    
   172 000001C9 80F939                      cmp cl, '9'
   173 000001CC 772D                        ja stoi64_err_exit
   174                                  
   175 000001CE 80E930                      sub cl, '0'                     ; Вычитаем '0' (в utf-8 = 32) из знака для получения "цифры"
   176 000001D1 BB0A000000                  mov rbx, 10                     ; Не заполняем rax, так как он и так используется в качестве 
   177                                                                      ; первого операнда mul и будет хранить результат нашей конвертации
   178 000001D6 48F7E3                      mul rbx                         ; rax * 10
   179                                  
   180 000001D9 480FB6C9                    movzx rcx, cl                   ; Расширить 8 бит до 64-х
   181                                      
   182 000001DD 4801C8                      add rax, rcx
   183 000001E0 49FFC0                      inc r8
   184                                  
   185 000001E3 EBD6                        jmp stoi64_loop                 ; Повторяем, пока не обработаем все знаки
   186                                  
   187                                  stoi64_neg:
   188 000001E5 49C7C1FFFFFFFF              mov r9, -1
   189 000001EC 49FFC0                      inc r8
   190 000001EF EBCA                        jmp stoi64_loop
   191                                  
   192                                  ; Для отладки на данный момент
   193                                  stoi64_end:
   194 000001F1 4D85C9                      test r9, r9
   195 000001F4 7801                        js stoi64_neg_end
   196                                   
   197 000001F6 C3                          ret
   198                                  
   199                                  stoi64_neg_end:
   200 000001F7 48F7D8                      neg rax
   201 000001FA C3                          ret
   202                                  
   203                                  ; Вот и функция, которая может вернуть отрицательное число, при этом желательно
   204                                  ; сделать возврат ошибок. Согласно стандарту, функции должны возвращать
   205                                  ; коды ошибок отрицательным числом, так как быть в данном случае?
   206                                  ; Какое бы число я в данном случае не вернул, оно может интерпретироваться
   207                                  ; по-разному. Как ошибка и как число. 
   208                                  ; Единственный вариант решения, который я вижу, это передача 
   209                                  ; указателя на переменную, в которую напрямую будет
   210                                  ; записываться результат конвертации, а возвращаемое значение функции всегда
   211                                  ; будет кодом ошибки. (На С сделал бы именно так)
   212                                  ; Если успею реализую данный функционал.
   213                                  stoi64_err_exit:
   214 000001FB 880D(00000000)              mov [char_to_print], cl    
   215 00000201 48BE-                       mov rsi, char_to_print
   215 00000203 [0000000000000000] 
   216 0000020B BA01000000                  mov rdx, 1
   217 00000210 E8B2000000                  call write_stdout    
   218                                  
   219 00000215 48BE-                       mov rsi, err_wrong_char
   219 00000217 [5600000000000000] 
   220 0000021F BA23000000                  mov rdx, err_wrong_char_len
   221 00000224 E89E000000                  call write_stdout
   222 00000229 E9D2FDFFFF                  jmp _start
   223                                  
   224                                  ; --- stoi64 ---
   225                                  
   226                                  ; --- itos64 ---
   227                                  itos64:
   228 0000022E 4831C0                      xor rax, rax
   229 00000231 4989D0                      mov r8, rdx             ; Сохранить размер переданного буфера, так как в операции div rdx будет перезаписан
   230 00000234 4D31C9                      xor r9, r9    
   231 00000237 4D31D2                      xor r10, r10
   232                                  
   233 0000023A 4883FF00                    cmp rdi, 0
   234 0000023E 742E                        jz itos64_zero
   235                                  
   236 00000240 4885FF                      test rdi, rdi
   237 00000243 7865                        js itos64_neg    
   238                                      
   239                                  itos64_loop:
   240 00000245 4883FF00                    cmp rdi, 0              ; Если обработали все число - выходим
   241 00000249 7431                        jz itos64_fill_output   ; Если просто выйти, то в output окажется перевернутое число, 
   242                                                              ; так как число мы обрабатываем от младшего к
   243                                                              ; старшему.
   244                                          
   245 0000024B 4889F8                      mov rax, rdi            ; Младшая часть делимого
   246 0000024E 4831D2                      xor rdx, rdx            ; Согласно ТЗ ограничение -32768..32768, так что старшей части никогда не будет
   247 00000251 B90A000000                  mov rcx, 10             ; Делим на 10, rax будет содержать результат целочисленного деления
   248                                                              ; rdx будет содержать остаток от деления
   249 00000256 48F7F1                      div rcx
   250                                      
   251 00000259 4889C7                      mov rdi, rax            ; Переносим результат деления в rdi для дальнейшей обработки
   252 0000025C 80C230                      add dl, '0'             ; добавляем '0' для превращения в знак
   253 0000025F 480FB6D2                    movzx rdx, dl 
   254 00000263 52                          push rdx
   255 00000264 49FFC1                      inc r9
   256                                  
   257 00000267 4D39C1                      cmp r9, r8              ; Проверяем на overflow
   258 0000026A 774C                        ja itos64_exit_err
   259                                      
   260 0000026C EBD7                        jmp itos64_loop 
   261                                  
   262                                  itos64_zero:
   263 0000026E 4831D2                      xor rdx, rdx
   264 00000271 80C230                      add dl, '0'
   265 00000274 480FB6D2                    movzx rdx, dl
   266 00000278 52                          push rdx
   267 00000279 49FFC1                      inc r9
   268                                  
   269                                  itos64_fill_output:
   270 0000027C 4831C9                      xor rcx, rcx           ; Если число отрицательное, запись начнется с индекса 1
   271                                      
   272 0000027F 4D85D2                      test r10, r10               ; Проверка на наличие знака у числа
   273 00000282 7408                        jz itos64_fill_output_loop
   274 00000284 C6062D                      mov byte [rsi], '-'
   275 00000287 B901000000                  mov rcx, 1
   276                                  
   277                                  itos64_fill_output_loop:
   278 0000028C 4C39C9                      cmp rcx, r9            ; До этого мы запсали в r11 единицу, если число было отрицательным. Данная проверка выйден на единицу раньше и не перезапишет '-'.
   279 0000028F 740E                        je itos64_end    
   280                                  
   281 00000291 5A                          pop rdx
   282 00000292 88140E                      mov byte [rsi + rcx], dl
   283 00000295 48FFC1                      inc rcx
   284                                     
   285 00000298 4C39C1                      cmp rcx, r8              ; Проверяем на overflow
   286 0000029B 771B                        ja itos64_exit_err
   287                                      
   288 0000029D EBED                        jmp itos64_fill_output_loop
   289                                  
   290                                  ; Вернуть кол-во записанных в массив байт    
   291                                  itos64_end:
   292 0000029F C6040E00                    mov byte [rsi + rcx], 0
   293 000002A3 48FFC1                      inc rcx
   294                                  
   295 000002A6 4889C8                      mov rax, rcx
   296 000002A9 C3                          ret
   297                                  
   298                                  itos64_neg:
   299 000002AA 41BA01000000                mov r10, 1
   300 000002B0 48F7DF                      neg rdi
   301 000002B3 49FFC1                      inc r9
   302 000002B6 EB8D                        jmp itos64_loop
   303                                  
   304                                  itos64_exit_err:
   305 000002B8 48C7C0FFFFFFFF              mov rax, -1
   306 000002BF C3                          ret
   307                                  
   308                                  ; --- itos64 ---
   309                                  
   310                                  ; --- sum ---
   311                                  sum_of_two:
   312 000002C0 4889F8                      mov rax, rdi
   313 000002C3 4801F0                      add rax, rsi
   314 000002C6 C3                          ret
   315                                  ; --- sum ---
   316                                  
   317                                  ; --- write_stdout ---
   318                                  ; @brief    Фукнция для записи в stdout
   319                                  ; @param    rsi - указатель на буфер, из которого будут извлечены данные
   320                                  ; @param    rdx - количество байт, которые необходимо записать в stdout
   321                                  ; @return   rax - размер записанных в stdout данных
   322                                  ; @note     Аналог на Си: int write_stdout(char* data, size_t input_size)
   323                                  ; @note     Проверяет rax на соответствие r9 после записи в stdout
   324                                  write_stdout:
   325 000002C7 B801000000                  mov rax, 1                      ; 1 - sys_write
   326 000002CC BF01000000                  mov rdi, 1                      ; 1 - stdout
   327 000002D1 0F05                        syscall
   328                                  
   329 000002D3 4839C2                      cmp rdx, rax                    ; Проверить, что все данные были записаны в stdout
   330 000002D6 750D                        jnz exit_with_error
   331 000002D8 C3                          ret
   332                                  ; --- write_stdout ---
   333                                  
   334                                  ; Выход
   335                                  exit:
   336 000002D9 B83C000000                  mov rax, 60
   337 000002DE BF00000000                  mov rdi, 0                  ; Возвращаем 0 при успешном завершении
   338 000002E3 0F05                        syscall
   339                                  
   340                                  ; Выход из программы с ошибкой
   341                                  exit_with_error:
   342 000002E5 B801000000                  mov rax, 1
   343 000002EA BF02000000                  mov rdi, 2
   344 000002EF 48BE-                       mov rsi, err_critical_problem
   344 000002F1 [7900000000000000] 
   345 000002F9 BA5E000000                  mov rdx, err_critical_problem_len
   346 000002FE 0F05                        syscall
   347                                  
   348 00000300 B83C000000                  mov rax, 60
   349 00000305 BF01000000                  mov rdi, 1
   350 0000030A 0F05                        syscall
