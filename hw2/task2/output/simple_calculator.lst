     1                                  bits 64
     2                                  default rel
     3                                  global _start
     4                                  
     5                                  section .data
     6 00000000 00                          char_to_print db 0
     7 00000001 577269746520666972-         write1_msg db "Write first number: ", 0
     7 0000000A 7374206E756D626572-
     7 00000013 3A2000             
     8                                      write1_msg_len  equ $ - write1_msg
     9 00000016 577269746520736563-         write2_msg db "Write second number: ", 0
     9 0000001F 6F6E64206E756D6265-
     9 00000028 723A2000           
    10                                      write2_msg_len equ $ - write2_msg
    11 0000002C 202B2000                    plus_msg db " + ", 0
    12                                      plus_msg_len equ $ - plus_msg
    13 00000030 203D2000                    equals_msg db " = ", 0
    14                                      equals_msg_len equ $ - equals_msg
    15 00000034 496E7075742073686F-         err_empty_str db "Input should contain atleast one digit, please try again", 10
    15 0000003D 756C6420636F6E7461-
    15 00000046 696E2061746C656173-
    15 0000004F 74206F6E6520646967-
    15 00000058 69742C20706C656173-
    15 00000061 652074727920616761-
    15 0000006A 696E0A             
    16                                      err_empty_str_len equ $ - err_empty_str
    17 0000006D 206973206E6F742061-         err_wrong_char db " is not a decimal digit, try again", 10
    17 00000076 20646563696D616C20-
    17 0000007F 64696769742C207472-
    17 00000088 7920616761696E0A   
    18                                      err_wrong_char_len equ $ - err_wrong_char
    19 00000090 50726F6772616D2065-         err_critical_problem db "Program encountered critical error during read_stdin, number conversion, summ or write_stdout", 10
    19 00000099 6E636F756E74657265-
    19 000000A2 642063726974696361-
    19 000000AB 6C206572726F722064-
    19 000000B4 7572696E6720726561-
    19 000000BD 645F737464696E2C20-
    19 000000C6 6E756D62657220636F-
    19 000000CF 6E76657273696F6E2C-
    19 000000D8 2073756D6D206F7220-
    19 000000E1 77726974655F737464-
    19 000000EA 6F75740A           
    20                                      err_critical_problem_len equ $ - err_critical_problem
    21                                  
    22                                  section .bss
    23 00000000 <res 400h>                  input resb      1024           ; 1KB массив для входных данных
    24 00000400 0000000000000000            first_number    dq      0      ; 64bit переменная для хранения первого числа
    24          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    25 00000408 0000000000000000            second_number   dq      0      ; 64bit переменная для хранения второго числа
    25          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    26 00000410 0000000000000000            sum             dq      0      ; 64bit переменная для суммы двух чисел
    26          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    27 00000418 <res 400h>                  output resb     1024           ; 1KB массив для выходных данных
    28                                  
    29                                  section .text
    30                                  _start:
    31 00000000 48BE-                       mov rsi, write1_msg             ; Выводим сообщение о необходимости ввести число
    31 00000002 [0100000000000000] 
    32 0000000A BA15000000                  mov rdx, write1_msg_len
    33 0000000F E8C8020000                  call write_stdout    
    34                                  
    35 00000014 48BB-                       mov rbx, input                  ; Передаем указатель на массив, куда попадет исходная строка
    35 00000016 [0000000000000000] 
    36 0000001E B900040000                  mov rcx, 1024                   ; Передаем размер этого массива
    37 00000023 E858010000                  call read_stdin                 ; Вызываем функцию чтения из stdin
    38                                  
    39 00000028 48BF-                       mov rdi, input                  ; Передаем указатель на массив, содержащий число в виде строки
    39 0000002A [0000000000000000] 
    40                                      
    41 00000032 E887010000                  call stoi64                     ; Вызываем функцию "переворота" строки
    42                                  
    43 00000037 488905(00040000)            mov [first_number], rax         ; Сохраняем первое число в переменную
    44                                  
    45 0000003E 48BE-                       mov rsi, write2_msg             ; Выводим сообщение о необходимости ввести второе число
    45 00000040 [1600000000000000] 
    46 00000048 BA16000000                  mov rdx, write2_msg_len
    47 0000004D E88A020000                  call write_stdout
    48                                  
    49 00000052 48BB-                       mov rbx, input                  ; Читаем второе число
    49 00000054 [0000000000000000] 
    50 0000005C B900040000                  mov rcx, 1024
    51 00000061 E81A010000                  call read_stdin
    52                                  
    53 00000066 48BF-                       mov rdi, input                  ; Конвертируем второе число
    53 00000068 [0000000000000000] 
    54 00000070 E849010000                  call stoi64
    55                                  
    56 00000075 488905(08040000)            mov [second_number], rax        ; Сохраняем его
    57                                  
    58 0000007C 488B3D(00040000)            mov rdi, [first_number]         ; Передаем первое число в функцию сложения
    59 00000083 488B35(08040000)            mov rsi, [second_number]        ; Передаем второе число в функцию сложения
    60                                  
    61 0000008A E846020000                  call sum_of_two                 ; Вызываем функцию складывания
    62                                  
    63 0000008F 488905(10040000)            mov [sum], rax
    64                                      
    65 00000096 488B3D(00040000)            mov rdi, [first_number]         ; Передаем значение переменной
    66 0000009D 48BE-                       mov rsi, output                 ; Передаем указатель на массив, куда попадет строка 
    66 0000009F [1804000000000000] 
    67 000000A7 BA00040000                  mov rdx, 1024                   ; Длина переданного массива для проверки на overflow
    68 000000AC E892010000                  call itos64
    69                                  
    70 000000B1 4885C0                      test rax, rax                   ; Проверка на отсутствие ошибки
    71 000000B4 0F8840020000                js exit_with_error
    72                                  
    73 000000BA 48BE-                       mov rsi, output                 ; Выводим первое число
    73 000000BC [1804000000000000] 
    74 000000C4 4889C2                      mov rdx, rax
    75 000000C7 E810020000                  call write_stdout
    76                                  
    77 000000CC 48BE-                       mov rsi, plus_msg               ; Выводим знак +
    77 000000CE [2C00000000000000] 
    78 000000D6 BA04000000                  mov rdx, plus_msg_len
    79 000000DB E8FC010000                  call write_stdout
    80                                  
    81 000000E0 488B3D(08040000)            mov rdi, [second_number]        ; Конвертируем второе число в строку
    82 000000E7 48BE-                       mov rsi, output
    82 000000E9 [1804000000000000] 
    83 000000F1 BA00040000                  mov rdx, 1024
    84 000000F6 E848010000                  call itos64
    85                                  
    86 000000FB 4885C0                      test rax, rax                   ; Проверяем на отсутствие ошибки
    87 000000FE 0F88F6010000                js exit_with_error
    88                                  
    89 00000104 48BE-                       mov rsi, output                 ; Выводим второе число
    89 00000106 [1804000000000000] 
    90 0000010E 4889C2                      mov rdx, rax
    91 00000111 E8C6010000                  call write_stdout
    92                                  
    93 00000116 48BE-                       mov rsi, equals_msg             ; Выводим знак =
    93 00000118 [3000000000000000] 
    94 00000120 BA04000000                  mov rdx, equals_msg_len
    95 00000125 E8B2010000                  call write_stdout
    96                                  
    97 0000012A 488B3D(10040000)            mov rdi, [sum]                  ; Конвертируем результат сложения
    98 00000131 48BE-                       mov rsi, output
    98 00000133 [1804000000000000] 
    99 0000013B BA00040000                  mov rdx, 1024
   100 00000140 E8FE000000                  call itos64
   101                                      
   102 00000145 4885C0                      test rax, rax                   ; Проверяем на отсутствие ошибки
   103 00000148 0F88AC010000                js exit_with_error
   104                                      
   105 0000014E 48BE-                       mov rsi, output                 ; Выводим сумму
   105 00000150 [1804000000000000] 
   106 00000158 4889C2                      mov rdx, rax
   107 0000015B E87C010000                  call write_stdout
   108                                  
   109 00000160 C605(00000000)0A            mov byte [char_to_print], 10    ; Перевод каретки
   110 00000167 48BE-                       mov rsi, char_to_print
   110 00000169 [0000000000000000] 
   111 00000171 BA01000000                  mov rdx, 1
   112 00000176 E861010000                  call write_stdout
   113                                  
   114 0000017B E96E010000                  jmp exit
   115                                  
   116                                  ; --- read_stdin ---
   117                                  ; @brief    Фукнция для чтения из stdin
   118                                  ; @param    rbx - указатель на массив, в который будут записаны данные
   119                                  ; @param    rcx - размер переданного массива
   120                                  ; @return   rax - размер записанных в массив данных
   121                                  ; @note     Аналог на Си: int read_stdin(char* input, size_t input_size)
   122                                  ; @note     Проверяет rax на содержание кода ошибки (отрицательное число) после
   123                                  ; @note     чтения из stdin
   124                                  read_stdin:
   125 00000180 B800000000                  mov rax, 0                      ; 0 - sys_read
   126 00000185 BF00000000                  mov rdi, 0                      ; 0 - stdin
   127 0000018A 4889DE                      mov rsi, rbx                    ; передаем указатель на массив, в который попадут введенные данные
   128 0000018D 4889CA                      mov rdx, rcx 
   129 00000190 0F05                        syscall
   130                                  
   131 00000192 4885C0                      test rax, rax                   ; Проверка на корректное вовзращенное значение (>=0)
   132 00000195 0F885F010000                js exit_with_error
   133                                  
   134 0000019B 803D(00000000)0A            cmp byte [input], 0x0A          ; Проверка на строку, стостоящую только из перевода каретки 
   135 000001A2 7401                        je empty_string_warning         ; Переход, если первый знак в input == 0x0A
   136                                  
   137 000001A4 C3                          ret
   138                                  
   139                                  ; Сообщение о пустой строке
   140                                  empty_string_warning:
   141 000001A5 48BE-                       mov rsi, err_empty_str          ; Передаем указатель на строку с информацей об ошибке 
   141 000001A7 [3400000000000000] 
   142 000001AF BA39000000                  mov rdx, err_empty_str_len      ; Передаем ее длину 
   143 000001B4 E823010000                  call write_stdout               ; Вызываем функцию записи в stdout
   144                                  
   145 000001B9 E942FEFFFF                  jmp _start                  ; Повторяем попытку получить корректную строку от пользователя
   146                                  ; --- read_stdin ---
   147                                  
   148                                  ; --- stoi64 ---
   149                                  ; @brief    Фукнция для "переворота" строки
   150                                  ; @param    rdi - указатель на массив исходных данных
   151                                  ; @return   rax - строка переведенная в число
   152                                  ; @note     Аналог на Си: int stoi64(char* input)
   153                                  ; @note     Если в процессе парсинка встретилась не цифра, сообщает об этом и
   154                                  ; @note     возвращается к старту
   155                                  
   156                                  ; Инициализация необходимых значений
   157                                  stoi64:
   158 000001BE 4831C0                      xor rax, rax
   159 000001C1 4D31C0                      xor r8, r8
   160 000001C4 4D31C9                      xor r9, r9
   161                                      
   162 000001C7 428A0C07                    mov cl, [rdi + r8]              ; Проверяем первый знак на наличие '-' 
   163 000001CB 80F92D                      cmp cl, '-'
   164 000001CE 742A                        je stoi64_neg                  ; Переходим к конвертации отрицательного числа 
   165                                  
   166                                  stoi64_loop:
   167 000001D0 428A0C07                    mov cl, [rdi + r8]              ; Получаем текущий знак 
   168                                                                      ; cl - младший байт регистра RAX, в данном случае необходим, так как данные длиной 1 байт  
   169                                  
   170 000001D4 80F90A                      cmp cl, 10                      ; Проверяем на перевод каретки или нуль-терминатор
   171 000001D7 7E2D                        jle stoi64_end    
   172                                      
   173                                      ; Проверяем, что обрабатываем цифру, а не какой-либо другой знак
   174 000001D9 80F930                      cmp cl, '0'                     
   175 000001DC 7C32                        jl stoi64_err_exit    
   176 000001DE 80F939                      cmp cl, '9'
   177 000001E1 772D                        ja stoi64_err_exit
   178                                  
   179 000001E3 80E930                      sub cl, '0'                     ; Вычитаем '0' (в utf-8 = 32) из знака для получения "цифры"
   180 000001E6 BB0A000000                  mov rbx, 10                     ; Не заполняем rax, так как он и так используется в качестве 
   181                                                                      ; первого операнда mul и будет хранить результат нашей конвертации
   182 000001EB 48F7E3                      mul rbx                         ; rax * 10
   183                                  
   184 000001EE 480FB6C9                    movzx rcx, cl                   ; Расширить 8 бит до 64-х
   185                                      
   186 000001F2 4801C8                      add rax, rcx
   187 000001F5 49FFC0                      inc r8
   188                                  
   189 000001F8 EBD6                        jmp stoi64_loop                 ; Повторяем, пока не обработаем все знаки
   190                                  
   191                                  stoi64_neg:
   192 000001FA 49C7C1FFFFFFFF              mov r9, -1
   193 00000201 49FFC0                      inc r8
   194 00000204 EBCA                        jmp stoi64_loop
   195                                  
   196                                  ; Для отладки на данный момент
   197                                  stoi64_end:
   198 00000206 4D85C9                      test r9, r9
   199 00000209 7801                        js stoi64_neg_end
   200                                   
   201 0000020B C3                          ret
   202                                  
   203                                  stoi64_neg_end:
   204 0000020C 48F7D8                      neg rax
   205 0000020F C3                          ret
   206                                  
   207                                  ; Вот и функция, которая может вернуть отрицательное число, при этом желательно
   208                                  ; сделать возврат ошибок. Согласно стандарту, функции должны возвращать
   209                                  ; коды ошибок отрицательным числом, так как быть в данном случае?
   210                                  ; Какое бы число я в данном случае не вернул, оно может интерпретироваться
   211                                  ; по-разному. Как ошибка и как число. 
   212                                  ; Единственный вариант решения, который я вижу, это передача 
   213                                  ; указателя на переменную, в которую напрямую будет
   214                                  ; записываться результат конвертации, а возвращаемое значение функции всегда
   215                                  ; будет кодом ошибки. (На С сделал бы именно так)
   216                                  ; Если успею реализую данный функционал.
   217                                  stoi64_err_exit:
   218 00000210 880D(00000000)              mov [char_to_print], cl    
   219 00000216 48BE-                       mov rsi, char_to_print
   219 00000218 [0000000000000000] 
   220 00000220 BA01000000                  mov rdx, 1
   221 00000225 E8B2000000                  call write_stdout    
   222                                  
   223 0000022A 48BE-                       mov rsi, err_wrong_char
   223 0000022C [6D00000000000000] 
   224 00000234 BA23000000                  mov rdx, err_wrong_char_len
   225 00000239 E89E000000                  call write_stdout
   226 0000023E E9BDFDFFFF                  jmp _start
   227                                  
   228                                  ; --- stoi64 ---
   229                                  
   230                                  
   231                                  ; --- itos64 ---
   232                                  ; @brief    Фукнция для конвертации int64 в string
   233                                  ; @param    rdi - значение переменной для конвертации
   234                                  ; @param    rsi - указатель на массив, куда попадут сконвертированные данные
   235                                  ; @param    rdx - размер переданного в rsi массива
   236                                  ; @return   rax - количество байт, записанных в rsi
   237                                  ; @note     Аналог на Си: int itos64(int num, char* out_bif, size_t buf_size)
   238                                  ; @note     Если в процессе парсинга происходит выход за границы массива,
   239                                  ; @note     возвращает -1
   240                                  itos64:
   241 00000243 4831C0                      xor rax, rax
   242 00000246 4989D0                      mov r8, rdx             ; Сохранить размер переданного буфера, так как в операции div rdx будет перезаписан
   243 00000249 4D31C9                      xor r9, r9    
   244 0000024C 4D31D2                      xor r10, r10
   245                                  
   246 0000024F 4883FF00                    cmp rdi, 0              ; Если встретили 0, добавляем его в стэк, пропуская цикл
   247 00000253 742E                        jz itos64_zero
   248                                  
   249 00000255 4885FF                      test rdi, rdi
   250 00000258 7865                        js itos64_neg    
   251                                      
   252                                  itos64_loop:
   253 0000025A 4883FF00                    cmp rdi, 0              ; Если обработали все число - выходим
   254 0000025E 7431                        jz itos64_fill_output   ; Если просто выйти, то в output окажется перевернутое число, 
   255                                                              ; так как число мы обрабатываем от младшего к
   256                                                              ; старшему.
   257                                          
   258 00000260 4889F8                      mov rax, rdi            ; Младшая часть делимого
   259 00000263 4831D2                      xor rdx, rdx            ; Согласно ТЗ ограничение -32768..32768, так что старшей части никогда не будет
   260 00000266 B90A000000                  mov rcx, 10             ; Делим на 10, rax будет содержать результат целочисленного деления
   261                                                              ; rdx будет содержать остаток от деления
   262 0000026B 48F7F1                      div rcx
   263                                      
   264 0000026E 4889C7                      mov rdi, rax            ; Переносим результат деления в rdi для дальнейшей обработки
   265 00000271 80C230                      add dl, '0'             ; добавляем '0' для превращения в знак
   266 00000274 480FB6D2                    movzx rdx, dl 
   267 00000278 52                          push rdx
   268 00000279 49FFC1                      inc r9
   269                                  
   270 0000027C 4D39C1                      cmp r9, r8              ; Проверяем на overflow
   271 0000027F 774C                        ja itos64_exit_err
   272                                      
   273 00000281 EBD7                        jmp itos64_loop 
   274                                  
   275                                  itos64_zero:
   276 00000283 4831D2                      xor rdx, rdx
   277 00000286 80C230                      add dl, '0'
   278 00000289 480FB6D2                    movzx rdx, dl
   279 0000028D 52                          push rdx
   280 0000028E 49FFC1                      inc r9
   281                                  
   282                                  itos64_fill_output:
   283 00000291 4831C9                      xor rcx, rcx           ; Если число отрицательное, запись начнется с индекса 1
   284                                      
   285 00000294 4D85D2                      test r10, r10               ; Проверка на наличие знака у числа
   286 00000297 7408                        jz itos64_fill_output_loop
   287 00000299 C6062D                      mov byte [rsi], '-'
   288 0000029C B901000000                  mov rcx, 1
   289                                  
   290                                  itos64_fill_output_loop:
   291 000002A1 4C39C9                      cmp rcx, r9            ; До этого мы запсали в r11 единицу, если число было отрицательным. Данная проверка выйден на единицу раньше и не перезапишет '-'.
   292 000002A4 740E                        je itos64_end    
   293                                  
   294 000002A6 5A                          pop rdx
   295 000002A7 88140E                      mov byte [rsi + rcx], dl
   296 000002AA 48FFC1                      inc rcx
   297                                     
   298 000002AD 4C39C1                      cmp rcx, r8              ; Проверяем на overflow
   299 000002B0 771B                        ja itos64_exit_err
   300                                      
   301 000002B2 EBED                        jmp itos64_fill_output_loop
   302                                  
   303                                  ; Вернуть кол-во записанных в массив байт    
   304                                  itos64_end:
   305 000002B4 C6040E00                    mov byte [rsi + rcx], 0
   306 000002B8 48FFC1                      inc rcx
   307                                  
   308 000002BB 4889C8                      mov rax, rcx
   309 000002BE C3                          ret
   310                                  
   311                                  itos64_neg:
   312 000002BF 41BA01000000                mov r10, 1
   313 000002C5 48F7DF                      neg rdi
   314 000002C8 49FFC1                      inc r9
   315 000002CB EB8D                        jmp itos64_loop
   316                                  
   317                                  itos64_exit_err:
   318 000002CD 48C7C0FFFFFFFF              mov rax, -1
   319 000002D4 C3                          ret
   320                                  
   321                                  ; --- itos64 ---
   322                                  
   323                                  ; --- sum ---
   324                                  ; @brief    Фукнция для суммы двух чисел
   325                                  ; @param    rdi - первое число
   326                                  ; @param    rsi - второе число
   327                                  ; @return   rax - результат суммы
   328                                  sum_of_two:
   329 000002D5 4889F8                      mov rax, rdi
   330 000002D8 4801F0                      add rax, rsi
   331 000002DB C3                          ret
   332                                  ; --- sum ---
   333                                  
   334                                  ; --- write_stdout ---
   335                                  ; @brief    Фукнция для записи в stdout
   336                                  ; @param    rsi - указатель на буфер, из которого будут извлечены данные
   337                                  ; @param    rdx - количество байт, которые необходимо записать в stdout
   338                                  ; @return   rax - размер записанных в stdout данных
   339                                  ; @note     Аналог на Си: int write_stdout(char* data, size_t input_size)
   340                                  ; @note     Проверяет rax на соответствие r9 после записи в stdout
   341                                  write_stdout:
   342 000002DC B801000000                  mov rax, 1                      ; 1 - sys_write
   343 000002E1 BF01000000                  mov rdi, 1                      ; 1 - stdout
   344 000002E6 0F05                        syscall
   345                                  
   346 000002E8 4839C2                      cmp rdx, rax                    ; Проверить, что все данные были записаны в stdout
   347 000002EB 750D                        jnz exit_with_error
   348 000002ED C3                          ret
   349                                  ; --- write_stdout ---
   350                                  
   351                                  ; Выход
   352                                  exit:
   353 000002EE B83C000000                  mov rax, 60
   354 000002F3 BF00000000                  mov rdi, 0                  ; Возвращаем 0 при успешном завершении
   355 000002F8 0F05                        syscall
   356                                  
   357                                  ; Выход из программы с ошибкой
   358                                  exit_with_error:
   359 000002FA B801000000                  mov rax, 1
   360 000002FF BF02000000                  mov rdi, 2
   361 00000304 48BE-                       mov rsi, err_critical_problem
   361 00000306 [9000000000000000] 
   362 0000030E BA5E000000                  mov rdx, err_critical_problem_len
   363 00000313 0F05                        syscall
   364                                  
   365 00000315 B83C000000                  mov rax, 60
   366 0000031A BF01000000                  mov rdi, 1
   367 0000031F 0F05                        syscall
