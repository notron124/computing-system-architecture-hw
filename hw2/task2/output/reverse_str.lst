     1                                  bits 64
     2                                  default rel
     3                                  global _start
     4                                  
     5                                  section .data
     6 00000000 577269746520736F6D-         write_msg db "Write some string: ", 0
     6 00000009 6520737472696E673A-
     6 00000012 2000               
     7                                      write_msg_len  equ $ - write_msg
     8 00000014 52657665727365643A-         reversed_msg db "Reversed: ", 0
     8 0000001D 2000               
     9                                      reversed_msg_len equ $ - reversed_msg
    10 0000001F 537472696E67207368-         err_empty_str db "String should contain at least one character, try again", 10
    10 00000028 6F756C6420636F6E74-
    10 00000031 61696E206174206C65-
    10 0000003A 617374206F6E652063-
    10 00000043 68617261637465722C-
    10 0000004C 207472792061676169-
    10 00000055 6E0A               
    11                                      err_empty_str_len equ $ - err_empty_str
    12 00000057 50726F6772616D2065-         err_critical_problem db "Program encountered critical error during read_stdin, flip_string or write_stdout", 10
    12 00000060 6E636F756E74657265-
    12 00000069 642063726974696361-
    12 00000072 6C206572726F722064-
    12 0000007B 7572696E6720726561-
    12 00000084 645F737464696E2C20-
    12 0000008D 666C69705F73747269-
    12 00000096 6E67206F7220777269-
    12 0000009F 74655F7374646F7574-
    12 000000A8 0A                 
    13                                      err_critical_problem_len equ $ - err_critical_problem
    14                                  
    15                                  section .bss
    16 00000000 <res 400h>                  input resb 1024             ; 1KB массив для входных данных
    17 00000400 <res 400h>                  reversed_str resb 1024      ; 1KB массив для "перевернутой" строки
    18                                  
    19                                  section .text
    20                                  _start:
    21 00000000 48BB-                       mov rbx, input                  ; Передаем указатель на массив, куда попадет исходная строка
    21 00000002 [0000000000000000] 
    22 0000000A B900040000                  mov rcx, 1024                   ; Передаем размер этого массива
    23 0000000F E859000000                  call read_stdin                 ; Вызываем функцию чтения из stdin
    24                                  
    25 00000014 48BF-                       mov rdi, input                  ; Передаем указатель на массив, содержащий исходную строку
    25 00000016 [0000000000000000] 
    26 0000001E 48BE-                       mov rsi, reversed_str           ; Передаем указатель на массив, куда попадет перевернутая строка
    26 00000020 [0004000000000000] 
    27 00000028 4889C2                      mov rdx, rax                    ; Передаем размер исходной строки
    28                                  
    29 0000002B 41B900040000                mov r9, 1024                    ; Передаем размер reversed_std
    30 00000031 4989C2                      mov r10, rax                    ; Сохраняем размер исходной строки
    31                                  
    32 00000034 E889000000                  call flip_string                ; Вызываем функцию "переворота" строки
    33                                      
    34 00000039 4939C2                      cmp r10, rax                    ; Проверяем, что "переворот" строки прошел успешно
    35 0000003C 0F85E3000000                jnz exit_with_error
    36                                  
    37 00000042 48BE-                       mov rsi, reversed_msg           ; Выводим сообщение "Reversed: "
    37 00000044 [1400000000000000] 
    38 0000004C BA0B000000                  mov rdx, reversed_msg_len
    39 00000051 E8B1000000                  call write_stdout
    40                                  
    41 00000056 48BE-                       mov rsi, reversed_str           ; Выводим полученную строку 
    41 00000058 [0004000000000000] 
    42 00000060 4C89D2                      mov rdx, r10
    43 00000063 E89F000000                  call write_stdout
    44                                  
    45 00000068 E9AC000000                  jmp exit
    46                                  
    47                                  ; --- read_stdin ---
    48                                  ; @brief    Фукнция для чтения из stdin
    49                                  ; @param    rbx - указатель на массив, в который будут записаны данные
    50                                  ; @param    rcx - размер переданного массива
    51                                  ; @return   rax - размер записанных в массив данных
    52                                  ; @note     Аналог на Си: int read_stdin(char* input, size_t input_size)
    53                                  ; @note     Проверяет rax на содержание кода ошибки (отрицательное число) после
    54                                  ; @note     чтения из stdin
    55                                  read_stdin:
    56 0000006D 4989C8                      mov r8, rcx                     ; Сохранить rcx (rcx будет задействован в sys_write)
    57 00000070 48BE-                       mov rsi, write_msg              ; Выводим сообщение о необходимости ввести строку
    57 00000072 [0000000000000000] 
    58 0000007A BA14000000                  mov rdx, write_msg_len
    59 0000007F E883000000                  call write_stdout    
    60 00000084 4C89C1                      mov rcx, r8                     ; Восстановить rcx
    61                                  
    62 00000087 B800000000                  mov rax, 0                      ; 0 - sys_read
    63 0000008C BF00000000                  mov rdi, 0                      ; 0 - stdin
    64 00000091 4889DE                      mov rsi, rbx                    ; передаем указатель на массив, в который попадут введенные данные
    65 00000094 4889CA                      mov rdx, rcx 
    66 00000097 0F05                        syscall
    67                                  
    68 00000099 4885C0                      test rax, rax                   ; Проверка на корректное вовзращенное значение (>=0)
    69 0000009C 0F8883000000                js exit_with_error
    70                                  
    71 000000A2 803D(00000000)0A            cmp byte [input], 0x0A          ; Проверка на строку, стостоящую только из перевода каретки 
    72 000000A9 7401                        je empty_string_warning         ; Переход, если первый знак в input == 0x0A
    73                                  
    74 000000AB C3                          ret
    75                                  
    76                                  ; Сообщение о пустой строке
    77                                  empty_string_warning:
    78 000000AC 48BE-                       mov rsi, err_empty_str          ; Передаем указатель на строку с информацей об ошибке 
    78 000000AE [1F00000000000000] 
    79 000000B6 BA38000000                  mov rdx, err_empty_str_len      ; Передаем ее длину 
    80 000000BB E847000000                  call write_stdout               ; Вызываем функцию записи в stdout
    81                                  
    82 000000C0 EBAB                        jmp read_stdin                  ; Повторяем попытку получить корректную строку от пользователя
    83                                  ; --- read_stdin ---
    84                                  
    85                                  ; --- flip_string ---
    86                                  ; @brief    Фукнция для "переворота" строки
    87                                  ; @param    rdi - указатель на массив исходных данных
    88                                  ; @param    rsi - указатель на массив, куда будет записана "перевенутая" строка
    89                                  ; @param    rdx - размер исходных данных
    90                                  ; @param    r9  - размер массива для записи данных (rsi)
    91                                  ; @return   rax - размер записанных в массив, переданный в rsi, данных
    92                                  ; @note     Аналог на Си: int flip_string(char* input, char* output, size_t input_size)
    93                                  ; @note     Если rdx < 1 возвращает код ошибки -1
    94                                  ; @note     Если размер исходных занных больше размера массива для записи
    95                                  ; @note     данных, возвращаемт код ошибки -2 
    96                                  
    97                                  ; Инициализация необходимых значений
    98                                  flip_string:
    99 000000C2 4883FA01                    cmp rdx, 1                      ; Если размер исходных данных меньше 1
   100 000000C6 7C2F                        jl exit_flip_string_with_error  ; выходим с ошибкой
   101                                  
   102 000000C8 4C39CA                      cmp rdx, r9                     ; Если размер исходных данных больше размера
   103 000000CB 7F32                        jg exit_flip_string_overflow    ; массива, куда будут попадать "перевернутые" данные, выходим с ошибкой
   104                                  
   105 000000CD 4889D1                      mov rcx, rdx                    ; Инициализируем счетчик, который будет указывать на текущий последний знак в строке
   106 000000D0 48FFC9                      dec rcx                         ; Пропускаем перевод каретки
   107 000000D3 4D31C9                      xor r9, r9                      ; обнуляем r9, так как будем исользовать
   108                                                                      ; его в качестве счетчика обработанный байт
   109                                  
   110                                  ; "Переворот" данных
   111                                  flip_string_loop:
   112 000000D6 48FFC9                      dec rcx                         ; уменьшаем счетчик, который указывает на конец input
   113 000000D9 780C                        js end_flip_string              ; если он стал отрицательным, значит инвесия закончена - выходим
   114                                  
   115 000000DB 8A040F                      mov al, [rdi + rcx]             ; Получаем последний знак на данный момент 
   116                                                                      ; al - младший байт регистра RAX, в данном случае необходим, так как данные длиной 1 байт 
   117 000000DE 4288040E                    mov [rsi + r9], al              ; помещаем последний знак в начало reversed_str
   118 000000E2 49FFC1                      inc r9
   119                                  
   120 000000E5 EBEF                        jmp flip_string_loop            ; Повторяем, пока не обработаем все знаки
   121                                  
   122                                  ; Вставка перевода каретки в конец перевернутой строки
   123                                  end_flip_string: 
   124 000000E7 B00A                        mov al, 10
   125 000000E9 418881[00040000]            mov [reversed_str + r9], al     ; Перевод каретки
   126 000000F0 49FFC1                      inc r9
   127                                  
   128 000000F3 4C89C8                      mov rax, r9
   129                                  
   130 000000F6 C3                          ret
   131                                  
   132                                  exit_flip_string_with_error:
   133 000000F7 48C7C0FFFFFFFF              mov rax, -1
   134 000000FE C3                          ret
   135                                  
   136                                  exit_flip_string_overflow:
   137 000000FF 48C7C0FEFFFFFF              mov rax, -2
   138 00000106 C3                          ret
   139                                  ; --- flip_string ---
   140                                  
   141                                  ; --- write_stdout ---
   142                                  ; @brief    Фукнция для записи в stdout
   143                                  ; @param    r9 - указатель на буфер, из которого будут извлечены данные
   144                                  ; @param    r10 - количество байт, которые необходимо записать в stdout
   145                                  ; @return   rax - размер записанных в stdout данных
   146                                  ; @note     Аналог на Си: int write_stdout(char* data, size_t input_size)
   147                                  ; @note     Проверяет rax на соответствие r9 после записи в stdout
   148                                  write_stdout:
   149 00000107 B801000000                  mov rax, 1                      ; 1 - sys_write
   150 0000010C BF01000000                  mov rdi, 1                      ; 1 - stdout
   151 00000111 0F05                        syscall
   152                                  
   153 00000113 4839C2                      cmp rdx, rax                    ; Проверить, что все данные были записаны в stdout
   154 00000116 750D                        jnz exit_with_error
   155 00000118 C3                          ret
   156                                  ; --- write_stdout ---
   157                                  
   158                                  ; Выход
   159                                  exit:
   160 00000119 B83C000000                  mov rax, 60
   161 0000011E BF00000000                  mov rdi, 0                  ; Возвращаем 0 при успешном завершении
   162 00000123 0F05                        syscall
   163                                  
   164                                  ; Выход из программы с ошибкой
   165                                  exit_with_error:
   166 00000125 B801000000                  mov rax, 1
   167 0000012A BF02000000                  mov rdi, 2
   168 0000012F 48BE-                       mov rsi, err_critical_problem
   168 00000131 [5700000000000000] 
   169 00000139 BA52000000                  mov rdx, err_critical_problem_len
   170 0000013E 0F05                        syscall
   171                                  
   172 00000140 B83C000000                  mov rax, 60
   173 00000145 BF01000000                  mov rdi, 1
   174 0000014A 0F05                        syscall
